package main

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"net/url"
	"strconv"
	"strings"
	"time"

	"github.com/gin-gonic/gin"
)

const channelID = "1655240709"
const channelSecret = "964856232bdd0a84c7497e9c3b4657f6"
const rediretURL = "https://b45ab6d5eb93.ngrok.io/oauth/login"

type ResponseWithError struct {
	*http.Response
	body []byte
}

type LineAccessType struct {
	AccessToken  string `json:"access_token"`
	TokenType    string `json:"token_type"`
	ID_Token     string `json:"id_token"` // scope=openid 才會有這欄位
	RefreshToken string `json:"refresh_token"`
	ExpiresIn    int    `json:"expires_in"`
	Scope        string `json:"scope"`
}

// 取會員授權碼
func getAccessToken(code string) (*LineAccessType, *ResponseWithError, error) {
	// Generated by curl-to-Go: https://mholt.github.io/curl-to-go
	// Original command: curl -X POST https://api.line.me/oauth2/v2.1/token -H 'Content-Type: application/x-www-form-urlencoded' -d 'grant_type=authorization_code' -d 'code=xxx' -d 'redirect_uri=xxx' -d 'client_id=xxx' -d 'client_secret=xxx'
	body := url.Values{}
	body.Set("grant_type", "authorization_code")
	body.Set("code", code)
	body.Set("client_id", channelID)
	body.Set("client_secret", channelSecret)
	body.Set("redirect_uri", rediretURL)
	req, err := http.NewRequest("POST", "https://api.line.me/oauth2/v2.1/token", strings.NewReader(body.Encode()))
	if err != nil {
		return nil, nil, err
	}

	req.Header.Set("Content-Type", "application/x-www-form-urlencoded")

	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return nil, nil, err
	}
	defer resp.Body.Close()

	data, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, &ResponseWithError{resp, data}, err
	}

	if resp.StatusCode != 200 {
		return nil, &ResponseWithError{resp, data}, err
	}

	var result LineAccessType
	err = json.Unmarshal(data, &result)
	if err != nil {
		return nil, &ResponseWithError{resp, data}, err
	}

	return &result, &ResponseWithError{resp, data}, nil
}

type LineProfileType struct {
	UserID        string `json:"userId"`
	DisplayName   string `json:"displayName"`
	PictureURL    string `json:"pictureUrl"`
	StatusMessage string `json:"statusMessage"`
}

// 取會員基本資料(包含user_id)
func getProfile(token string) (*LineProfileType, *ResponseWithError, error) {
	// Generated by curl-to-Go: https://mholt.github.io/curl-to-go
	// Original command: curl -v -X GET https://api.line.me/v2/profile -H 'Authorization: Bearer {access token}'

	req, err := http.NewRequest("GET", "https://api.line.me/v2/profile", nil)
	if err != nil {
		return nil, nil, err
	}
	req.Header.Set("Authorization", "Bearer "+token)

	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return nil, nil, err
	}
	defer resp.Body.Close()

	data, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, &ResponseWithError{resp, data}, err
	}
	// log.Printf("data -> %+v \n", string(data))
	var result LineProfileType
	err = json.Unmarshal(data, &result)
	if err != nil {
		return nil, &ResponseWithError{resp, data}, err
	}

	return &result, &ResponseWithError{resp, data}, nil
}

func main() {
	r := gin.Default()
	r.GET("/login", func(c *gin.Context) {
		link := &url.URL{
			Scheme: "https",
			Host:   "access.line.me",
			Path:   "/oauth2/v2.1/authorize",
		}
		query := link.Query()
		query.Set("response_type", "code")
		query.Set("client_id", channelID)
		query.Set("redirect_uri", rediretURL)
		query.Set("scope", "profile")                                // 指定只需要基本資料 (包含user_id)
		query.Set("state", "game=1")                                 // state 可以帶入一些自定義資訊
		query.Set("nonce", strconv.FormatInt(time.Now().Unix(), 10)) // 純粹給予亂數
		link.RawQuery = query.Encode()

		c.Redirect(http.StatusTemporaryRedirect, link.String())
	})

	r.GET("/oauth/login", func(c *gin.Context) {
		code := c.Query("code") // 取得一個短碼，用來取 access token
		log.Println("code ----> ", code)
		if code == "" {
			c.Status(http.StatusNotFound)
			return
		}

		state := c.Query("state") // 取得登入前的自定義資訊
		log.Printf("自訂資訊，可用來做其他事情，例如記在cookie做判斷事情: %+v\n", state)

		access, resp, err := getAccessToken(code)
		if err != nil {
			if resp != nil {
				c.String(200, "登入失敗: %+v\n [%s] %+v", err, resp.Status, string(resp.body))
			} else {
				c.String(200, "登入失敗: %+v", err)
			}
			return
		}

		log.Printf("取得會員存取權限: %+v\n", access)

		profile, resp, err := getProfile(access.AccessToken)
		if err != nil {
			if resp != nil {
				c.String(200, "登入失敗: %+v\n [%s] %+v", err, resp.Status, string(resp.body))
			} else {
				c.String(200, "登入失敗: %+v", err)
			}
			return
		}

		log.Printf("取得會員資訊: %+v\n", profile)

		// 成功由Line登入並取到會員資訊，開始 SetCooike 與 轉導到首頁或其他頁面
		query := url.Values{}
		query.Set("access_token", access.AccessToken)
		query.Set("refresh_token", access.RefreshToken)
		query.Set("state", state)
		c.SetCookie("token", query.Encode(), int(time.Hour/time.Second), "", "", false, false)
		c.Redirect(http.StatusTemporaryRedirect, "/")
	})

	r.GET("/", func(c *gin.Context) {

		// 確認Cookie有無設定
		token, err := c.Cookie("token")
		if err != nil {
			c.String(200, "請先登入 /login")
			return
		}

		query, err := url.ParseQuery(token)
		accessToken := query.Get("access_token")
		if err != nil || accessToken == "" {
			c.String(200, "請先登入 /login")
			return
		}

		profile, resp, err := getProfile(accessToken)
		if err != nil {
			if !(resp != nil && resp.StatusCode == http.StatusTooManyRequests) {
				c.String(200, "目前系統繁忙，請等一下")
				return
			}
			c.String(200, "請先登入 /login")
			return
		}

		c.Writer.Header().Set("Content-Type", "text/html")
		c.Writer.Write([]byte(fmt.Sprintf(`
		<h1> Welcome~ %s , Your ID is %s</h1> 
		<img src="%s" width="100px" height="100px"/>
		`, profile.DisplayName, profile.UserID, profile.PictureURL)))
	})

	r.NoRoute(func(c *gin.Context) {
		log.Println("===========================")
		log.Println("Method ==> ", c.Request.Method)
		log.Println("Path ==> ", c.Request.RequestURI)
		c.String(200, "沒有這個路由唷! [%s] %s", c.Request.Method, c.Request.RequestURI)
	})
	log.Fatal(r.Run(":8082"))
}
